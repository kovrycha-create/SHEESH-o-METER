<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cyberpunk Sheesh-O-Meter</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary: #00e5ff;
        --secondary: #ff00a0;
        --accent: #fffc00;
        --background: #0a0a15;
        --text-color: #ffffff;
        --low-value: #00e5ff;
        --mid-value: #26ff00;
        --high-value: #ff00a0;
        --peak-value: var(--accent);
        --data-lines: rgba(0, 229, 255, 0.15);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background-color: transparent;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: "Rajdhani", "Orbitron", sans-serif;
      }
      body.dragging {
        cursor: grabbing;
        user-select: none;
      }

      #container {
        width: 300px;
        height: 600px;
        background-color: var(--background);
        background-image: radial-gradient(
            circle at 20% 30%,
            rgba(0, 229, 255, 0.05) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(255, 0, 160, 0.05) 0%,
            transparent 50%
          );
        border-radius: 8px;
        padding: 20px;
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        gap: 15px; /* Adjusted gap */
        box-shadow: 0 0 40px rgba(0, 229, 255, 0.25);
        overflow: hidden;
        transition: all 1s;
      }
      
      #dynamic-border {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        pointer-events: none;
        z-index: 12;
        transition: border-width 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        border: 1px solid rgba(0, 229, 255, 0.3);
      }

      #container.glitch {
        animation: glitch-anim 0.5s linear;
      }

      #container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--primary),
          transparent
        );
        box-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary);
        animation: scanline 4s linear infinite;
        z-index: 9;
        opacity: 0.8;
      }

      #container::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
            90deg,
            transparent 50%,
            rgba(0, 229, 255, 0.03) 50%
          ),
          linear-gradient(rgba(0, 229, 255, 0.03) 50%, transparent 50%);
        background-size: 2px 2px;
        pointer-events: none;
        z-index: 11;
        opacity: 0.3;
      }

      @keyframes scanline {
        0% { transform: translateY(-10px); }
        100% { transform: translateY(100%); }
      }

      #background-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(
            var(--data-lines) 1px,
            transparent 1px
          ),
          linear-gradient(90deg, var(--data-lines) 1px, transparent 1px);
        background-size: 20px 20px;
        z-index: 0;
        perspective: 800px;
        transform-style: preserve-3d;
      }
      
      @keyframes dynamicGridPulse {
        50% {
          transform: scale(var(--pulse-scale, 1));
          background-size: var(--pulse-bg-size, 20px 20px);
          opacity: 1;
        }
      }
      
      @keyframes peakGridGlow {
        0%, 100% { box-shadow: 0 0 50px -20px var(--accent); }
        50% { box-shadow: 0 0 50px 20px var(--accent); }
      }
      
      .peak-grid-glow {
        animation: peakGridGlow 1.5s infinite ease-in-out !important;
      }


      #peak-flash {
        position: absolute;
        inset: 0;
        background: radial-gradient(ellipse at center, 
          rgba(255, 215, 0, 0.7) 0%, 
          rgba(255, 215, 0, 0) 60%
        );
        opacity: 0;
        transform: scale(0.5);
        pointer-events: none;
        z-index: 1;
      }

      #container.peak-flash-active #peak-flash {
        opacity: 1;
        transform: scale(1.5);
        transition: opacity 0.2s ease-in, transform 1s ease-out;
      }


      #background-grid::before {
        content: "";
        position: absolute;
        top: -100%;
        left: -100%;
        width: 300%;
        height: 300%;
        background-image: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.8) 100%
        );
        z-index: 1;
        pointer-events: none;
      }

      #background-grid::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(
            var(--data-lines) 1px,
            transparent 1px
          ),
          linear-gradient(90deg, var(--data-lines) 1px, transparent 1px);
        background-size: 100px 100px;
        z-index: 2;
        opacity: 0.4;
        transform: rotateX(45deg) scale(2) translateZ(-50px);
        animation: gridMovement 30s infinite linear;
      }

      @keyframes gridMovement { 0% { transform: rotateX(45deg) scale(2) translateZ(-50px) translateY(0); } 100% { transform: rotateX(45deg) scale(2) translateZ(-50px) translateY(100px); } }

      #value-display {
        font-size: 72px;
        color: var(--text-color);
        z-index: 12;
        position: relative;
        font-weight: 700;
        display: flex;
        justify-content: center;
        align-items: center;
        letter-spacing: 2px;
        transition: text-shadow 0.3s ease;
        font-family: "Orbitron", sans-serif;
      }

      #value-display::before {
        content: "";
        position: absolute;
        top: -10px;
        left: -20px;
        right: -20px;
        height: 2px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--primary),
          transparent
        );
        opacity: 0.7;
      }

      #current-value {
        position: relative;
        animation: textFlicker 4s infinite alternate;
        transition: color 0.3s ease, text-shadow 0.3s ease;
      }
      
      #current-value.glitch {
        animation: glitch-anim 0.5s linear;
      }

      @keyframes textFlicker { 0%, 5%, 10%, 15%, 20%, 100% { opacity: 1; } 7%, 17% { opacity: 0.8; } }

      #current-value::after {
        content: "";
        position: absolute;
        bottom: -3px;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--primary),
          transparent
        );
        animation: pulseLine 2s infinite;
        box-shadow: 0 0 10px var(--primary);
        opacity: 0.5;
      }

      #current-value::before {
        content: "";
        position: absolute;
        bottom: -8px;
        left: 10%;
        width: 80%;
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--primary),
          transparent
        );
        opacity: 0.3;
      }

      @keyframes pulseLine { 0%, 100% { opacity: 0.3; transform: scaleX(0.8); } 50% { opacity: 1; transform: scaleX(1); } }
      
      @keyframes zero-pulse {
        0%, 100% { color: var(--text-color); transform: scale(1); text-shadow: none; }
        50% { color: #ff3b3b; text-shadow: 0 0 15px #ff3b3b, 0 0 25px #ff3b3b; transform: scale(1.05); }
      }
      #current-value.zero-pulse {
        animation: zero-pulse 2s ease-in-out;
      }

      #confetti-container {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none;
        overflow: hidden;
      }
      .confetti {
        position: absolute;
        width: 8px;
        height: 15px;
        opacity: 0;
        animation: confetti-fall 3s ease-out forwards;
      }
      @keyframes confetti-fall {
        0% { transform: translateY(-50px) rotateZ(0deg); opacity: 1; }
        100% { transform: translateY(150px) rotateZ(720deg); opacity: 0; }
      }

      #meter-container {
        position: relative;
        width: 120px;
        height: 290px; /* Increased height */
        z-index: 2;
        perspective: 800px;
        margin-top: -10px; /* Nudge up */
      }

      #meter-container::before {
        content: "";
        position: absolute;
        top: -10px;
        left: -15px;
        width: 150px;
        height: 310px; /* Increased height */
        background: transparent;
        border: 1px solid rgba(0, 229, 255, 0.2);
        clip-path: polygon(0% 0%, 100% 0%, 95% 100%, 5% 100%);
        z-index: -1;
        opacity: 0.3;
      }

      #meter-container::after {
        content: "";
        position: absolute;
        top: 5px;
        left: 5px;
        width: 110px;
        height: 280px; /* Increased height */
        background: transparent;
        border: 1px dashed rgba(0, 229, 255, 0.3);
        clip-path: polygon(0% 0%, 100% 0%, 92% 100%, 8% 100%);
        z-index: -1;
        animation: borderGlow 4s infinite alternate;
      }

      @keyframes borderGlow { 0% { border-color: rgba(0, 229, 255, 0.1); box-shadow: none; } 100% { border-color: rgba(0, 229, 255, 0.4); box-shadow: 0 0 10px rgba(0, 229, 255, 0.1); } }

      #meter {
        position: absolute;
        width: 100%;
        height: 100%;
        clip-path: polygon(0% 0%, 100% 0%, 90% 100%, 10% 100%);
        background: linear-gradient(
          0deg,
          rgba(0, 229, 255, 0.05),
          rgba(0, 229, 255, 0.07)
        );
        border: 1px solid rgba(0, 229, 255, 0.5);
        box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
        backdrop-filter: blur(5px);
        transform-style: preserve-3d;
        cursor: pointer;
      }

      #meter::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 10px,
          rgba(0, 229, 255, 0.03) 10px,
          rgba(0, 229, 255, 0.03) 12px
        );
        z-index: 0;
        pointer-events: none;
      }

      #meter-fill {
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 0%;
        clip-path: polygon(0% 0%, 100% 0%, 90% 100%, 10% 100%);
        background: linear-gradient(
          0deg,
          var(--low-value),
          var(--mid-value) 50%,
          var(--high-value) 75%,
          var(--peak-value) 95%
        );
        overflow: hidden;
        transition: box-shadow 0.3s ease;
      }

      @keyframes flowing-energy {
        0% { background-position: 0% 0%; }
        100% { background-position: -200% -200%; }
      }

      #meter-fill::after {
        content: "";
        position: absolute;
        inset: 0;
        background:
          radial-gradient(ellipse at 70% 30%, rgba(255,255,255,0.2) 0%, transparent 40%),
          radial-gradient(ellipse at 20% 80%, rgba(255,255,255,0.15) 0%, transparent 30%),
          linear-gradient(-45deg, transparent 45%, rgba(255,255,255,0.1) 50%, transparent 55%);
        background-size: 200% 200%;
        mix-blend-mode: overlay;
        opacity: var(--energy-opacity, 0);
        animation: flowing-energy 8s linear infinite;
        transition: opacity 0.5s ease;
      }


      #meter-fill::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 150%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transform: translateX(-100%);
        animation: shimmer 3s infinite;
      }

      @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
      
      @keyframes sliderPulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

      #value-slider {
        position: absolute;
        left: -15px;
        width: 150px;
        height: 25px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid;
        border-radius: 3px;
        transform-origin: center;
        z-index: 10;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        padding: 4px;
        cursor: grab;
      }
      
      #value-slider:active {
        cursor: grabbing;
      }

      #value-slider.peak {
        animation: sliderPulse 1.5s infinite ease-in-out;
      }

      .slider-arrow {
        width: 10px;
        height: 16px;
        border-style: none;
        cursor: pointer;
        transition: transform 0.2s ease, background-color 0.3s ease;
      }
      .slider-arrow:hover { transform: scale(1.1); }
      .slider-arrow-left { clip-path: polygon(100% 0, 0 50%, 100% 100%); }
      .slider-arrow-right { clip-path: polygon(0 0, 100% 50%, 0 100%); }

      .slider-content {
        height: 2px;
        flex-grow: 1;
        margin: 0 5px;
      }

      #meter-edge {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        clip-path: polygon(0% 0%, 100% 0%, 90% 100%, 10% 100%);
        border: 2px solid transparent;
        background: linear-gradient(135deg, var(--primary), transparent 70%) border-box;
        -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
        z-index: 4;
        box-shadow: 0 0 15px rgba(0, 229, 255, 0.5);
        pointer-events: none;
        transition: background 0.3s ease, box-shadow 0.3s ease;
        animation: edgePulse 4s infinite ease-in-out;
      }

      @keyframes edgePulse {
        0%, 100% {
          box-shadow: 0 0 15px rgba(0, 229, 255, 0.5);
          opacity: 0.7;
        }
        50% {
          box-shadow: var(--edge-glow-color);
          opacity: 1;
        }
      }

      #average-container {
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2;
        position: relative;
        padding: 6px 16px;
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 4px;
        border: 1px solid rgba(0, 229, 255, 0.5);
        box-shadow: 0 0 15px rgba(0, 229, 255, 0.4), inset 0 0 5px rgba(0, 229, 255, 0.2);
        gap: 8px;
      }
      
      .avg-dot {
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
      }
      .avg-dot.top-left {
        top: 6px; left: 6px; background-color: var(--primary); box-shadow: 0 0 5px var(--primary);
      }
      .avg-dot.bottom-right {
        bottom: 6px; right: 6px; background-color: var(--secondary); box-shadow: 0 0 5px var(--secondary);
      }
      
      #average-label {
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        color: #ccc;
        letter-spacing: 1px;
      }

      #average-value {
        font-family: 'Rajdhani', sans-serif;
        font-size: 24px;
        font-weight: 700;
        color: #adecf1;
        text-shadow: 0 0 8px var(--primary);
        letter-spacing: 1px;
      }

      #history-graph {
        width: 100%;
        height: 80px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(0, 229, 255, 0.3);
        position: relative;
        z-index: 2;
        box-shadow: 0 0 15px rgba(0, 229, 255, 0.4);
        backdrop-filter: blur(2px);
      }

      #history-graph::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(
            var(--data-lines) 1px,
            transparent 1px
          ),
          linear-gradient(90deg, var(--data-lines) 1px, transparent 1px);
        background-size: 10px 10px;
        z-index: 1;
        opacity: 0.3;
        pointer-events: none;
      }

      #history-graph::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--primary),
          transparent
        );
        opacity: 0.7;
      }

      #history-canvas {
        width: 100%;
        height: 100%;
        position: relative;
        z-index: 3;
        cursor: crosshair;
      }

      #graph-tooltip {
        position: absolute;
        top: 0;
        left: 0;
        background-color: rgba(0, 0, 0, 0.8);
        color: var(--text-color);
        border: 1px solid var(--primary);
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 15;
        transform: translate(-50%, -120%);
        line-height: 1.4;
        text-align: left;
      }

      #bottom-controls-container {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        z-index: 13;
      }
      
      #decay-tooltip {
          position: absolute;
          bottom: 100%;
          left: 50%;
          transform: translateX(-50%);
          background: #000;
          color: #fff;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
          white-space: nowrap;
          border: 1px solid var(--primary);
          opacity: 0;
          visibility: hidden;
          transition: opacity 0.2s, visibility 0.2s;
      }

      #main-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 15px;
        position: relative;
      }

      #main-controls:hover #decay-tooltip {
          opacity: 1;
          visibility: visible;
      }

      .control-button {
        background-color: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--primary);
        color: var(--text-color);
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 12px;
        font-weight: bold;
        text-shadow: 0 0 5px var(--primary);
        box-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
      }

      .control-button::before {
        content: "";
        position: absolute;
        top: -10px;
        left: -10px;
        width: 150%;
        height: 50%;
        background: rgba(0, 229, 255, 0.3);
        transform: rotate(45deg) translateX(-100px);
        transition: transform 0.3s ease;
      }

      .control-button:hover {
        background-color: rgba(0, 229, 255, 0.2);
        box-shadow: 0 0 10px rgba(0, 229, 255, 0.7), 0 0 20px rgba(0, 229, 255, 0.4);
      }
      .control-button:hover::before { transform: rotate(45deg) translateX(100px); }
      .control-button.active { 
        color: var(--background);
        box-shadow: 0 0 15px var(--primary), inset 0 0 10px rgba(0,229,255,0.3);
        background-color: var(--primary);
      }
      
      input[type="range"]#decay-rate-slider {
        flex: 1;
        margin: 0;
      }

      .control-button.fast { border-color: var(--peak-value); color: var(--peak-value); text-shadow: 0 0 5px var(--peak-value); }
      .control-button.fast.active { background-color: var(--peak-value); color: var(--background); box-shadow: 0 0 20px var(--peak-value); }

      .control-button.medium { border-color: var(--high-value); color: var(--high-value); text-shadow: 0 0 5px var(--high-value); }
      .control-button.medium.active { background-color: var(--high-value); color: var(--background); box-shadow: 0 0 20px var(--high-value); }

      .control-button.slow { border-color: var(--mid-value); color: var(--mid-value); text-shadow: 0 0 5px var(--mid-value); }
      .control-button.slow.active { background-color: var(--mid-value); color: var(--background); box-shadow: 0 0 20px var(--mid-value); }
      
      #particle-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        overflow: hidden;
      }
      .particle {
        position: absolute;
        border-radius: 50%;
        background-color: var(--accent); /* Changed to accent */
        box-shadow: 0 0 8px var(--accent);
      }


      body.afk-mode::before {
        content: "";
        position: fixed;
        top: -50%; left: -50%; right: -50%; bottom: -50%;
        width: 200%; height: 200%;
        background: transparent url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuOCIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIiBmaWx0ZXI9InVybCgjbm9pc2UpIiBvcGFjaXR5PSIwLjE1Ii8+PC9zdmc+') ;
        opacity: .9;
        z-index: 19;
        animation: noise-anim .2s infinite;
        pointer-events: none;
      }
      
      @keyframes noise-anim {
        0% { transform: translate(0,0); }
        10% { transform: translate(-5%,-5%); }
        20% { transform: translate(-10%,5%); }
        30% { transform: translate(5%,-10%); }
        40% { transform: translate(-5%,15%); }
        50% { transform: translate(-10%,-5%); }
        60% { transform: translate(15%,0); }
        70% { transform: translate(0,10%); }
        80% { transform: translate(-15%,0); }
        90% { transform: translate(10%,5%); }
        100% { transform: translate(5%,0); }
      }

      .afk-mode #container {
        opacity: 0.4;
        filter: grayscale(1) blur(4px);
      }

      @keyframes afkPulse { 0% { box-shadow: 0 0 10px rgba(0, 229, 255, 0.1); } 100% { box-shadow: 0 0 30px rgba(0, 229, 255, 0.3); } }

      #afk-text {
        position: absolute;
        font-size: 28px;
        color: var(--primary);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: opacity 1s ease;
        z-index: 20;
        text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary);
        pointer-events: none;
        letter-spacing: 5px;
        font-weight: bold;
      }

      #afk-text::before {
        content: "";
        position: absolute;
        top: -20px;
        left: -30px;
        right: -30px;
        bottom: -20px;
        border: 2px dashed var(--primary);
        opacity: 0;
        transition: opacity 1s ease;
        animation: rotate 10s linear infinite;
      }

      @keyframes rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      .afk-mode #afk-text {
        opacity: 1;
        animation: afkGlitch 0.7s infinite linear;
      }

      .afk-mode #afk-text::before { opacity: 0.3; }

      @keyframes afkGlitch {
        0%, 100% { opacity: 1; transform: translate(-50%, -50%); }
        10% { transform: translate(calc(-50% - 5px), -50%); opacity: 0.8; }
        20% { transform: translate(calc(-50% + 5px), -50%); opacity: 1; }
        30% { transform: translate(-50%, calc(-50% - 5px)); opacity: 0.8; }
        40% { transform: translate(-50%, calc(-50% + 5px)); opacity: 1; }
        50% { opacity: 0.5; filter: blur(1px); }
        60% { opacity: 1; filter: blur(0); text-shadow: 0 0 20px var(--secondary); }
        70% { text-shadow: 0 0 10px var(--primary); }
        80% { transform: translate(-50%,-50%) skewX(-15deg); }
        90% { transform: translate(-50%,-50%) skewX(15deg); }
      }

      @keyframes glitch-anim { 0% { transform: translate(0); filter: hue-rotate(0deg) brightness(1); } 20% { transform: translate(-3px, 3px); filter: hue-rotate(90deg) brightness(1.2); } 40% { transform: translate(3px, -3px); filter: hue-rotate(180deg) brightness(0.8); } 60% { transform: translate(-3px, -3px); filter: hue-rotate(270deg) brightness(1.2); } 80% { transform: translate(3px, 3px); filter: hue-rotate(360deg) brightness(0.8); } 100% { transform: translate(0); filter: hue-rotate(0deg) brightness(1); } }

      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 5px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--primary);
        border-radius: 5px;
        outline: none;
        transition: opacity .2s;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 15px;
        height: 15px;
        background: var(--primary);
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid var(--background);
        box-shadow: 0 0 10px var(--primary);
      }

      input[type="range"]::-moz-range-thumb {
        width: 15px;
        height: 15px;
        background: var(--primary);
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid var(--background);
        box-shadow: 0 0 10px var(--primary);
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="dynamic-border"></div>
      <div id="background-grid"></div>
      <div id="peak-flash"></div>
      <div id="particle-container"></div>
      <div id="graph-tooltip"></div>

      <div id="value-display">
        <span id="current-value">0</span>
        <div id="confetti-container"></div>
      </div>

      <div id="meter-container">
        <div id="meter">
          <div id="meter-fill"></div>
          <div id="meter-edge"></div>
        </div>
        <div id="value-slider">
          <div class="slider-arrow slider-arrow-left"></div>
          <div class="slider-content"></div>
          <div class="slider-arrow slider-arrow-right"></div>
        </div>
      </div>

      <div id="average-container" title="Double-click to reset average and history">
        <div class="avg-dot top-left"></div>
        <span id="average-label">AVG</span>
        <span id="average-value">0.0</span>
        <div class="avg-dot bottom-right"></div>
      </div>

      <div id="history-graph">
        <canvas id="history-canvas"></canvas>
      </div>

      <div id="bottom-controls-container">
        <div id="main-controls">
          <div id="accelerated-decay" class="control-button" title="Toggle Accelerated Decay">A</div>
          <input type="range" id="decay-rate-slider" min="0" max="5" step="0.1" value="0.5">
          <div id="lock-decay" class="control-button" title="Lock Decay">L</div>
          <div id="decay-tooltip">Decay: 0.5</div>
        </div>
      </div>

      <div id="afk-text">AFK</div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // --- CONFIGURATION ---
        const config = {
          maxValue: 100,
          minValue: 0,
          initialValue: 0,
          decayRate: 0.5,
          acceleratedDecay: {
            slow: { baseRate: 0.3, accelerationFactor: 0.05, maxRate: 1.0 },
            medium: { baseRate: 0.5, accelerationFactor: 0.1, maxRate: 2.0 },
            fast: { baseRate: 0.8, accelerationFactor: 0.2, maxRate: 4.0 },
          },
          historyLength: 100,
          historyUpdateInterval: 250, // Faster update for smoother graph
          afkTimeout: 15000,
        };

        // --- STATE ---
        let currentValue = config.initialValue;
        let valuesHistory = Array(config.historyLength).fill(0);
        let averageValue = 0;
        let isDecayLocked = false;
        let acceleratedDecayMode = 'off';
        let isAfk = false;
        let isDragging = false;
        let spaceToggleState = 'to100';
        let spaceToggleResetTimer = null;
        let peakFlashTimeout = null;
        let lastConfettiTime = 0;
        let particles = [];
        
        let lastUpdateTime = Date.now();
        let lastInteractionTime = Date.now();
        let afkTimerId = null;

        // --- DOM ELEMENTS CACHE ---
        const dom = {
          container: document.getElementById("container"),
          dynamicBorder: document.getElementById("dynamic-border"),
          backgroundGrid: document.getElementById("background-grid"),
          currentValueDisplay: document.getElementById("current-value"),
          confettiContainer: document.getElementById("confetti-container"),
          averageContainer: document.getElementById("average-container"),
          averageValueDisplay: document.getElementById("average-value"),
          meter: document.getElementById("meter"),
          meterFill: document.getElementById("meter-fill"),
          meterEdge: document.getElementById("meter-edge"),
          valueSlider: document.getElementById("value-slider"),
          sliderArrows: document.querySelectorAll(".slider-arrow"),
          sliderContent: document.querySelector(".slider-content"),
          historyCanvas: document.getElementById("history-canvas"),
          graphTooltip: document.getElementById("graph-tooltip"),
          lockDecayButton: document.getElementById("lock-decay"),
          acceleratedDecayButton: document.getElementById("accelerated-decay"),
          decayRateSlider: document.getElementById("decay-rate-slider"),
          decayTooltip: document.getElementById("decay-tooltip"),
          particleContainer: document.getElementById("particle-container"),
          body: document.body,
        };
        const historyCtx = dom.historyCanvas.getContext("2d");

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = Math.random() * 1.5 + 0.5; // Move right
                this.vy = (Math.random() - 0.5) * 2;
                this.size = Math.random() * 2.5 + 1;
                this.life = Math.random() * 60 + 40; // longer life
                this.initialLife = this.life;
                this.element = document.createElement('div');
                this.element.className = 'particle';
                this.updateStyle();
                dom.particleContainer.appendChild(this.element);
            }

            updateStyle() {
                this.element.style.cssText = `
                    position: absolute;
                    left: ${this.x}px; top: ${this.y}px;
                    width: ${this.size}px; height: ${this.size}px;
                    opacity: ${Math.max(0, this.life / this.initialLife)};
                    background-color: var(--accent);
                    box-shadow: 0 0 8px var(--accent);
                    border-radius: 50%;
                `;
            }

            update() {
                this.life--;
                this.vy += 0.03; // gravity
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.life <= 0) {
                    this.element.remove();
                    return false;
                }
                
                this.updateStyle();
                return true;
            }
        }
        
        function updateParticles() {
            // Update existing
            particles = particles.filter(p => p.update());

            // Create new particles based on slider position
            const percentage = currentValue / config.maxValue;
            if (percentage > 0.05 && particles.length < 80) {
                const spawnCount = Math.floor(percentage * 1.5);
                const sliderRect = dom.valueSlider.getBoundingClientRect();
                const containerRect = dom.container.getBoundingClientRect();

                for (let i = 0; i < spawnCount; i++) {
                    const x = sliderRect.right - containerRect.left;
                    const y = sliderRect.top - containerRect.top + (sliderRect.height / 2);
                    particles.push(new Particle(x, y));
                }
            }
        }


        // --- CORE LOGIC ---
        const getMeterLevel = (value) => {
            const percentage = (value / config.maxValue) * 100;
            if (percentage >= 75) return 'peak';
            if (percentage >= 50) return 'high';
            if (percentage >= 25) return 'medium';
            return 'low';
        };

        const createConfetti = () => {
          const confettiCount = 30;
          const colors = ['var(--peak-value)', 'var(--high-value)', 'var(--primary)'];
          for (let i = 0; i < confettiCount; i++) {
            const confetti = document.createElement('div');
            confetti.classList.add('confetti');
            confetti.style.left = `${Math.random() * 100}%`;
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
            confetti.style.animationDelay = `${Math.random() * 0.5}s`;
            confetti.style.animationDuration = `${2 + Math.random() * 2}s`;
            dom.confettiContainer.appendChild(confetti);
            setTimeout(() => confetti.remove(), 4000);
          }
        };

        const setValue = (valueOrUpdater) => {
          const prevValue = currentValue;
          const newValue = typeof valueOrUpdater === 'function' ? valueOrUpdater(currentValue) : valueOrUpdater;
          currentValue = Math.max(config.minValue, Math.min(config.maxValue, newValue));

          if (currentValue === prevValue) return;

          if (prevValue > 0 && currentValue <= 0) {
              dom.currentValueDisplay.classList.add('zero-pulse');
              setTimeout(() => dom.currentValueDisplay.classList.remove('zero-pulse'), 2000);
          }

          if (prevValue < 100 && currentValue >= 100) {
            clearTimeout(peakFlashTimeout);
            dom.container.classList.add('peak-flash-active');
            dom.backgroundGrid.classList.add('peak-grid-glow');
            const now = Date.now();
            if (now - lastConfettiTime > 10000) {
                lastConfettiTime = now;
                createConfetti();
            }
          } else if (prevValue >= 100 && currentValue < 100) {
            dom.backgroundGrid.classList.remove('peak-grid-glow');
            clearTimeout(peakFlashTimeout);
            peakFlashTimeout = setTimeout(() => dom.container.classList.remove('peak-flash-active'), 2000);
          }

          handleInteraction();
          
          const changeAmount = Math.abs(currentValue - prevValue);
          if (changeAmount > 5) {
            dom.currentValueDisplay.classList.add("glitch");
            setTimeout(() => dom.currentValueDisplay.classList.remove("glitch"), 500);
          }
          
          updateUI();
        };

        const applyDecay = () => {
          if (isDecayLocked || currentValue <= config.minValue) {
              lastUpdateTime = Date.now();
              return;
          }
          const now = Date.now();
          const deltaTime = now - lastUpdateTime;
          lastUpdateTime = now;
          let currentDecayRate = config.decayRate;
          if (acceleratedDecayMode !== 'off') {
            const settings = config.acceleratedDecay[acceleratedDecayMode];
            const timeSinceInteraction = (now - lastInteractionTime) / 1000;
            const accelerationAmount = Math.min(
              timeSinceInteraction * settings.accelerationFactor,
              settings.maxRate - settings.baseRate
            );
            currentDecayRate = settings.baseRate + accelerationAmount;
          }
          const decayAmount = (currentDecayRate * deltaTime) / 1000;
          setValue(val => val - decayAmount);
        };
        
        const updateUI = () => {
          const percentage = (currentValue / config.maxValue) * 100;
          const level = getMeterLevel(currentValue);
          const color = `var(--${level}-value)`;

          // --- Dynamic Border Logic ---
          let borderWidth = '1px';
          let borderColor = 'rgba(0, 229, 255, 0.3)';
          let boxShadow = 'none';

          if (percentage >= 100) {
              borderWidth = '4px';
              borderColor = 'var(--accent)';
              boxShadow = '0 0 15px var(--accent), 0 0 25px var(--accent)';
          } else if (percentage > 75) {
              borderWidth = '3px';
              borderColor = 'var(--peak-value)';
              boxShadow = '0 0 10px var(--peak-value)';
          } else if (percentage > 50) {
              borderWidth = '3px';
              borderColor = 'var(--high-value)';
          } else if (percentage > 25) {
              borderWidth = '2px';
              borderColor = 'var(--mid-value)';
          } else if (percentage > 0) {
              borderWidth = '1px';
              borderColor = 'var(--low-value)';
          }

          dom.dynamicBorder.style.borderWidth = borderWidth;
          dom.dynamicBorder.style.borderColor = borderColor;
          dom.dynamicBorder.style.boxShadow = boxShadow;

          // --- Meter Fill and Glow Logic ---
          dom.meterFill.style.height = `${percentage}%`;
          if (percentage > 0) {
            const glowBlur = Math.round(5 + (percentage / 100) * 25);
            const glowSpread = Math.round(1 + (percentage / 100) * 6);
            dom.meterFill.style.boxShadow = `0 0 ${glowBlur}px ${glowSpread}px ${borderColor}`;
          } else {
            dom.meterFill.style.boxShadow = 'none';
          }
          const energyOpacity = Math.min(0.8, (percentage / 100) * 1.5);
          dom.meterFill.style.setProperty('--energy-opacity', energyOpacity);
          
          dom.valueSlider.style.top = `calc(${100 - percentage}% - 12.5px)`;
          const sliderBorderColor = `var(--${level === 'peak' ? 'accent' : level + '-value'})`;
          dom.valueSlider.style.borderColor = sliderBorderColor;
          dom.valueSlider.style.boxShadow = `0 0 10px ${sliderBorderColor}, 0 0 20px ${sliderBorderColor}`;
          
          dom.valueSlider.classList.toggle('peak', level === 'peak');
          const sliderColor = `var(--${level === 'peak' ? 'accent' : level + '-value'})`;
          dom.sliderArrows.forEach(arrow => arrow.style.backgroundColor = sliderColor);
          dom.sliderContent.style.backgroundColor = sliderColor;
          dom.sliderContent.style.boxShadow = `0 0 5px ${sliderColor}`;
          
          dom.currentValueDisplay.innerText = Math.round(currentValue);
          const textShadowIntensity = 10 + percentage * 0.9;
          const displayColor = level === 'peak' ? 'var(--accent)' : color;
          dom.currentValueDisplay.style.color = displayColor;
          
          let textShadow = level === 'high'
              ? `0 0 4px rgba(255, 255, 255, 0.5), 0 0 12px ${displayColor}, 0 0 25px ${displayColor}`
              : `0 0 ${textShadowIntensity * 0.2}px ${displayColor}, 0 0 ${textShadowIntensity * 0.4}px ${displayColor}, 0 0 ${textShadowIntensity * 0.6}px ${displayColor}`;
          dom.currentValueDisplay.style.textShadow = textShadow;

          // --- METER EDGE PULSE LOGIC ---
          let edgeColor = 'var(--primary)';
          let edgeGlowColor = '0 0 15px rgba(0, 229, 255, 0.5)';
          let animationDuration = '4s';

          if (percentage >= 95) {
              edgeColor = 'var(--accent)';
              edgeGlowColor = `0 0 25px ${edgeColor}, 0 0 40px ${edgeColor}`;
              animationDuration = '1.5s';
          } else if (percentage > 75) {
              edgeColor = 'var(--high-value)';
              edgeGlowColor = `0 0 20px ${edgeColor}, 0 0 30px ${edgeColor}`;
              animationDuration = '2s';
          } else if (percentage > 50) {
              edgeColor = 'var(--mid-value)';
              edgeGlowColor = `0 0 15px ${edgeColor}, 0 0 25px ${edgeColor}`;
              animationDuration = '3s';
          } else if (percentage > 0) {
              edgeColor = 'var(--low-value)';
              edgeGlowColor = `0 0 10px ${edgeColor}, 0 0 20px ${edgeColor}`;
              animationDuration = '4s';
          }

          dom.meterEdge.style.setProperty('--edge-glow-color', edgeGlowColor);
          dom.meterEdge.style.background = `linear-gradient(135deg, ${edgeColor}, transparent 70%) border-box`;
          dom.meterEdge.style.animationDuration = animationDuration;

          if (percentage <= 0) {
              dom.meterEdge.style.animationName = 'none';
              dom.meterEdge.style.boxShadow = '0 0 15px rgba(0, 229, 255, 0.5)';
              dom.meterEdge.style.background = `linear-gradient(135deg, var(--primary), transparent 70%) border-box`;
          } else {
              dom.meterEdge.style.animationName = 'edgePulse';
          }
          
          if (currentValue <= 0) {
              dom.backgroundGrid.style.animation = 'gridMovement 30s infinite linear';
          } else {
              const p = currentValue / config.maxValue;
              const duration = Math.max(0.5, 3 - p * 2.5).toFixed(2);
              const scale = (1 + p * 0.03).toFixed(3);
              const bgSize = (20 + p * 2).toFixed(1);
              dom.backgroundGrid.style.setProperty('--pulse-scale', scale);
              dom.backgroundGrid.style.setProperty('--pulse-bg-size', `${bgSize}px ${bgSize}px`);
              const baseAnimation = dom.backgroundGrid.classList.contains('peak-grid-glow') ? '' : `dynamicGridPulse ${duration}s infinite ease-in-out, `;
              dom.backgroundGrid.style.animation = `${baseAnimation}gridMovement 30s infinite linear`;
          }

          if (currentValue <= config.minValue && !afkTimerId && !isAfk) {
              afkTimerId = setTimeout(() => { isAfk = true; dom.body.classList.add("afk-mode"); }, config.afkTimeout);
          }
        };

        const updateHistoryGraph = () => {
          valuesHistory.push(currentValue);
          if (valuesHistory.length > config.historyLength) valuesHistory.shift();
          averageValue = valuesHistory.reduce((a, b) => a + b, 0) / valuesHistory.length || 0;
          dom.averageValueDisplay.innerText = averageValue.toFixed(1);

          const { width, height } = dom.historyCanvas;
          historyCtx.clearRect(0, 0, width, height);

          // Draw Average Line
          const avgY = height - (averageValue / config.maxValue) * height;
          historyCtx.beginPath();
          historyCtx.setLineDash([5, 5]);
          historyCtx.moveTo(0, avgY);
          historyCtx.lineTo(width, avgY);
          historyCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          historyCtx.lineWidth = 1;
          historyCtx.stroke();
          historyCtx.setLineDash([]);


          const computedStyles = getComputedStyle(document.documentElement);
          const highValueColor = computedStyles.getPropertyValue('--high-value').trim();
          const lowValueColor = computedStyles.getPropertyValue('--low-value').trim();
          
          // Draw Area Fill
          historyCtx.beginPath();
          historyCtx.moveTo(0, height);
          valuesHistory.forEach((val, i) => historyCtx.lineTo((i / (config.historyLength - 1)) * width, height - (val / config.maxValue) * height));
          historyCtx.lineTo(width, height);
          historyCtx.closePath();
          const fillGradient = historyCtx.createLinearGradient(0, 0, 0, height);
          fillGradient.addColorStop(0, 'rgba(255, 0, 160, 0.3)');
          fillGradient.addColorStop(1, 'rgba(0, 229, 255, 0.05)');
          historyCtx.fillStyle = fillGradient;
          historyCtx.fill();
          
          // Draw Main Line
          historyCtx.beginPath();
          valuesHistory.forEach((val, i) => {
            const x = (i / (config.historyLength - 1)) * width;
            const y = height - (val / config.maxValue) * height;
            i === 0 ? historyCtx.moveTo(x, y) : historyCtx.lineTo(x, y);
          });
          const strokeGradient = historyCtx.createLinearGradient(0, 0, 0, height);
          strokeGradient.addColorStop(0, highValueColor);
          strokeGradient.addColorStop(0.7, highValueColor);
          strokeGradient.addColorStop(1, lowValueColor);
          historyCtx.strokeStyle = strokeGradient;
          historyCtx.lineWidth = 3;
          historyCtx.shadowColor = highValueColor;
          historyCtx.shadowBlur = 15;
          historyCtx.stroke();
          historyCtx.shadowBlur = 0;
        };

        const handleInteraction = () => {
          lastInteractionTime = Date.now();
          if (afkTimerId) { clearTimeout(afkTimerId); afkTimerId = null; }
          if (isAfk) { isAfk = false; dom.body.classList.remove("afk-mode"); }
        };

        const toggleDecayLock = () => {
          isDecayLocked = !isDecayLocked;
          dom.lockDecayButton.classList.toggle("active", isDecayLocked);
        };

        const toggleAcceleratedDecay = () => {
          const modes = ['off', 'slow', 'medium', 'fast'];
          acceleratedDecayMode = modes[(modes.indexOf(acceleratedDecayMode) + 1) % modes.length];
          dom.acceleratedDecayButton.className = 'control-button';
          const states = { slow: 'S', medium: 'M', fast: 'F', off: 'A' };
          dom.acceleratedDecayButton.textContent = states[acceleratedDecayMode];
          if (acceleratedDecayMode !== 'off') dom.acceleratedDecayButton.classList.add(acceleratedDecayMode, 'active');
        };
        
        const setupEventListeners = () => {
            window.addEventListener("wheel", e => { if (e.altKey) { e.preventDefault(); setValue(v => v - Math.sign(e.deltaY) * 5); }}, { passive: false });
            window.addEventListener("keydown", e => {
                if (e.key === 'ArrowUp') setValue(v => v + 5);
                if (e.key === 'ArrowDown') setValue(v => v - 5);
                if (e.key === ' ') {
                  e.preventDefault();
                  clearTimeout(spaceToggleResetTimer);
                  setValue(spaceToggleState === 'to100' ? 100 : 0);
                  spaceToggleState = spaceToggleState === 'to100' ? 'to0' : 'to100';
                  spaceToggleResetTimer = setTimeout(() => { spaceToggleState = 'to100'; }, 3000);
                }
            });
            dom.lockDecayButton.addEventListener("click", toggleDecayLock);
            dom.acceleratedDecayButton.addEventListener("click", toggleAcceleratedDecay);
            dom.meter.addEventListener("click", (e) => setValue((1 - (e.clientY - dom.meter.getBoundingClientRect().top) / dom.meter.offsetHeight) * 100));
            dom.sliderArrows.forEach(arrow => {
              arrow.addEventListener('click', e => {
                e.stopPropagation();
                setValue(v => v + (arrow.classList.contains('slider-arrow-right') ? 1 : -1));
              });
            });

            dom.averageContainer.addEventListener('dblclick', () => {
                valuesHistory = Array(config.historyLength).fill(0);
                updateHistoryGraph();
            });
            
            dom.decayRateSlider.addEventListener('input', e => {
                config.decayRate = parseFloat(e.target.value);
                dom.decayTooltip.textContent = `Decay: ${config.decayRate.toFixed(1)}`;
            });
            
            // --- Graph Tooltip Logic ---
            dom.historyCanvas.addEventListener('mousemove', e => {
                const canvasRect = dom.historyCanvas.getBoundingClientRect();
                const containerRect = dom.container.getBoundingClientRect();
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;
                const index = Math.round((x / canvasRect.width) * (config.historyLength - 1));
                const value = valuesHistory[index];

                if (value !== undefined) {
                    dom.graphTooltip.style.opacity = '1';
                    
                    const tooltipX = canvasRect.left - containerRect.left + x;
                    const tooltipY = canvasRect.top - containerRect.top + y;
                    dom.graphTooltip.style.left = `${tooltipX}px`;
                    dom.graphTooltip.style.top = `${tooltipY}px`;
                    
                    if (y < canvasRect.height / 2) {
                        dom.graphTooltip.style.transform = 'translate(-50%, 25px)'; // Below
                    } else {
                        dom.graphTooltip.style.transform = 'translate(-50%, -120%)'; // Above
                    }

                    dom.graphTooltip.innerHTML = `Value: ${value.toFixed(1)}<br>Index: ${index}`;
                }
            });

            dom.historyCanvas.addEventListener('mouseout', () => {
                dom.graphTooltip.style.opacity = '0';
            });

            // --- Drag Logic ---
            const onDragMove = (e) => {
                if (!isDragging) return;
                const rect = dom.meter.getBoundingClientRect();
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setValue((1 - (clientY - rect.top) / rect.height) * 100);
            };
            const onDragEnd = () => {
                isDragging = false;
                dom.body.classList.remove('dragging');
                window.removeEventListener('mousemove', onDragMove);
                window.removeEventListener('mouseup', onDragEnd);
                window.removeEventListener('touchmove', onDragMove);
                window.removeEventListener('touchend', onDragEnd);
            };
            const onDragStart = () => {
                isDragging = true;
                dom.body.classList.add('dragging');
                window.addEventListener('mousemove', onDragMove);
                window.addEventListener('mouseup', onDragEnd);
                window.addEventListener('touchmove', onDragMove, { passive: false });
                window.addEventListener('touchend', onDragEnd);
            };
            dom.valueSlider.addEventListener('mousedown', onDragStart);
            dom.valueSlider.addEventListener('touchstart', onDragStart, { passive: true });
            window.addEventListener("resize", resizeCanvas);
        };
        
        function resizeCanvas() {
            dom.historyCanvas.width = dom.historyCanvas.offsetWidth;
            dom.historyCanvas.height = dom.historyCanvas.offsetHeight;
            updateHistoryGraph();
        }
        
        function mainLoop() {
            applyDecay();
            updateParticles();
            requestAnimationFrame(mainLoop);
        }

        resizeCanvas();
        updateUI();
        setupEventListeners();
        setInterval(updateHistoryGraph, config.historyUpdateInterval);
        mainLoop();
      });
    </script>
  </body>
</html>